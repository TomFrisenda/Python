#!/usr/bin/env python3
# Script:Naive_RSA.py
# Author:Tom Frisenda
# Created:07/10/2021
# Modified:21/01/2022
# Purpose:Implement "Naive RSA" into python

import random, secrets, math


def exhaustive_search(n):
    for i in range(2, 100):
        result = n % i
        if result == 0:
            break
        elif result == 1:
            return n


def Fermat(n):
    for i in range(math.sqrt(n).__round__()):
        a = random.randint(2, n)
        b = (a ** n - 1) % n
        if b == 1:
            return True
    return False


# Extended euclidean algorithm function (a,b)
def extended_euclidean(a, b):
    r, r1, s, s1, t, t1 = b, a, 0, 1, 1, 0
    while r != 0:
        q = (r1 // r)
        (r1, r) = (r, r1 - q * r)
        (s1, s) = (s, s1 - q * s)
        (t1, t) = (t, t1 - q * t)
    d = r1
    x = s1
    y = t1

    if d == 1:
        return True, d, x, y
    else:
        return False


# Creates lists for the sets (z/Nz), (z/Nz)*, (z/Mz), (z/Mz)*
remainders = []
remaindersM = []
mutual_primesN = []
mutual_primesM = []
# Takes as input the security parameter
u = int(input("Enter the security parameter 'nu'"))

# Generates random p & q within a selected range so they are large - until they pass extensive search and fermats , so will be prime
while True:
    p = random.randint((2 ** (u // 2) - 1), (2 ** (u // 2)))
    exhaustive_search(p)
    fermat_check = Fermat(p)
    if fermat_check:
        break
while True:
    q = random.randint((2 ** (u // 2) - 1), (2 ** (u // 2)))
    exhaustive_search(q)
    fermat_check = Fermat(q)
    if fermat_check:
        break

# create varaibles N(product of the two generated primes) and M (cardinality of (Z/NZ)* -PHI)
N = p * q
M = (p - 1) * (q - 1)
# counter temp variable for N and M
counter = N
counterM = M
starter = 2 ** (u - 1)

# Create the set (Z/NZ)
for i in range(counter):
    counter -= 1
    remainders.append(i)
# cycles through the remainders of N and use gcd EE , storing the numbers that have a GCD with M of 1 (Z/NZ)*
for i in range(len(remainders)):
    mutual_check = extended_euclidean(remainders[i], N)
    if mutual_check:
        mutual_primesN.append(remainders[i])

# Create the set (Z/MZ)
for i in range(counterM):
    counterM -= 1
    remaindersM.append(i)

# cycles through the remainders of M and use gcd EE , storing the numbers that have a GCD with M of 1 (Z/MZ)*
for i in range(len(remaindersM)):
    mutual_check = extended_euclidean(remaindersM[i], M)
    if mutual_check:
        mutual_primesM.append(remaindersM[i])

# e is selected randomly from the set (Z/MZ)*
e = secrets.choice(mutual_primesM)
null, gcd, d, y = extended_euclidean(e, M)
if d <= 0:
    d = M + d

pk = (N, e)
sk = (N, d)

print("---------------------------")
print("Setup:")
print("The first prime generated by the setup algorithm is p = " + str(p))
print("The Second prime generated by the setup algorithm is q = " + str(q))
print("The integer N = pq = " + str(N))
print("The encryption exponent is e = " + str(e))
print("The encryption exponent is d = " + str(d))
print("----------------------------")
print("Please enter an option:")
print("1 to Encrypt")
print("2 to Decrypt")
print("Any other number to quit")
response = int(input("Your option:"))
print("----------------------------")
while response not in (1, 2):
    response = int(input("Your option:"))
# Encryption
if response == 1:
    print("Encryption")
    print("your ciphertext space is the set {Z/NZ}= {0,1...", str(N - 1), " }")
    m = int(input("Please enter a number from this set:"))
    c = (m ** e) % N
    while m not in remainders:
        print("you must enter an integer from the set (Z/", str(N), "Z)")
        m = int(input("please enter a number from the set (N/NZ) which is above"))
    print("The ciphertext for your message ", str(m), " is ", str(c))
    print("----------------------------")
# Decryption
if response == 2:
    print("Decryption")
    print("your ciphertext space is the set {Z/NZ}= {0,1...", str(N - 1), " }")
    c = int(input("Please enter a number from this set:"))
    m = (c ** d) % N
    while c not in remainders:
        print("you must enter an integer from the set (Z/", str(N), "Z)")
        c = int(input("please enter a number from the set (N/NZ) which is above"))
    print("The Plaintext for your ciphertext ", str(c), " is ", str(m))
    print("----------------------------")
