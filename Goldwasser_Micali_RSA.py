#!/usr/bin/env python3
# Script:Goldwasser_Micali_RSA.py
# Author:Tom Frisenda
# Created:30/10/2021
# Modified:21/01/2022
# Purpose:Implement Goldwasser-Micali RSA (IND-CPA secure RSA)

import random, math


# Extended euclidean algorithm function (a,b)
def extended_euclidean(a, b):
    r, r1, s, s1, t, t1 = b, a, 0, 1, 1, 0
    while r != 0:
        q = (r1 // r)
        (r1, r) = (r, r1 - q * r)
        (s1, s) = (s, s1 - q * s)
        (t1, t) = (t, t1 - q * t)
    d = r1
    x = s1
    y = t1

    if d == 1:
        return True, d, x, y
    else:
        return False, d, x, y


# legendre symbol function (a,p)
def legendre_symbol(a, p):
    ls = a ** ((p - 1) // 2 % p)
    if ls == p - 1:
        return -1
    else:
        return 1


# chinese remainder theorem function (a,b,N,M)
def Chinese_remainder_Theorem(a, b, N, M):
    null, d, s, y = extended_euclidean(M, N)
    T = s % N
    if T < 0:
        T = (s + N) % N
    u = ((b - a) * T)
    u = u % N
    x = a + (u * M)
    return x


# function for checking if a number is even
def even_check(a):
    if a % 2 == 0:
        return True


def exhaustive_search(n):
    for i in range(2, 100):
        result = n % i
        if result == 0:
            break
        elif result == 1:
            return n


def Fermat(n):
    for i in range(math.sqrt(n).__round__()):
        a = random.randint(2, n)
        b = a ** (n - 1) % n
        if b == 1:
            return True
    return False


# Jacobi symbol function , -1 returned if a is part of QNR(quadratic non residue) , 0 if p divides a and 1 if a
# belongs to QR(quadratic residue)
def jacobi(a, b):
    if b <= 0 or b % 2 == 0:
        return 0
    j = 1
    if a < 0:
        a = -a
        if b % 4 == 3:
            j = -j
    while a != 0:
        while a % 2 == 0:
            a = a / 2
            if b % 8 == 3 or b % 8 == 5:
                j = -j
        (a, b) = (b, a)
        if a % 4 == 3 and b % 4 == 3:
            j = -j
        a = a % b
    if b == 1:
        return j
    return 0


# Quadratic-non-residue function
def QNR(p):
    a = 0
    while jacobi(a, p) != -1:
        a = random.randint(1, p)
    return a


# Psuedosquare function
def pseudosquare(p, q):
    a = QNR(p)
    b = QNR(q)
    return Chinese_remainder_Theorem(a, p, b, q)


# list for the sets (Z/NZ) and (Z/NZ)*
remainders = []
mutual_primesN = []

u = int(input("Enter the security parameter 'nu':"))
print("----------------------------")

# generate a prime of half security parameter bits (p)
while True:
    p = int(random.randint(2 ** ((u//2) -1), 2 ** (u // 2)))
    exhaustive_search(p)
    fermat_check = Fermat(p)
    if fermat_check:
        break
# generate a prime of half security parameter bits (q)
while True:
    q = int(random.randint(2 ** ((u//2) -1), 2 ** (u // 2)))
    exhaustive_search(q)
    fermat_check = Fermat(q)
    if fermat_check:
        break

# create variables N(product of the two generated primes) and M (cardinality of (Z/NZ)* -PHI)
N = p * q
# Creates variable y
y = pseudosquare(p, q)
# counter temp variable for  N
counter = N

# Create the set (Z/NZ)
for i in range(counter):
    counter -= 1
    remainders.append(i)
# cycles through the remainders of N and use gcd EE , storing the numbers that have a GCD with M of 1 (Z/NZ)*
for i in range(len(remainders)):
    mutual_check = extended_euclidean(remainders[i], N)
    if mutual_check:
        mutual_primesN.append(remainders[i])


print("Setup:")
print("The first prime generated by the setup algorithm is p = " + str(p))
print("The Second prime generated by the setup algorithm is q = " + str(q))
print("The integer N = pq = " + str(N))
print("The public key y =", str(y))
print("----------------------------")

pk = (N, y)
sk = (p, q)

print("Please enter an option:")
print("1 to Encrypt")
print("2 to Decrypt")
print("Any other number to quit")
response = int(input("Your option:"))
print("----------------------------")
while response not in (1, 2):
    response = int(input("Your option:"))
# Encryption
if response == 1:
    print("Encryption")
    print("your ciphertext space is the set: {0,1}")
    m = int(input("Please enter a number from this set"))
    while m not in (0,1):
        m = int(input("Please enter a number from this set"))
    x = random.choice(mutual_primesN)
    if m == 0:
        c = (x * x) % N
    elif m == 1:
        c = y * (x * x) % N
    print("The ciphertext for your message ", str(m), " is ", str(c))
    print("----------------------------")
# Decryption
if response == 2:
    print("Decryption")
    print("your ciphertext space is the set J_", str(N))
    c = int(input("Please enter a number from this set"))
    while c not in range(1, N):
        print("you must enter an integer from the set (Z/", str(N - 1), "Z).")
        c = int(input("please enter a number from the set (N/NZ) which is above"))
    if legendre_symbol(c, p) == 1:
        m = 0
    if legendre_symbol(c, p) == -1:
        m = 1
    print("The plaintext for your ciphertext", str(c), " is ", (m))
    print("----------------------------")

